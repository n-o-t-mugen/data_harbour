================================================================================
FULL PROJECT CODE DUMP
Root Directory: /Users/mruthunjai_govindaraju/Downloads/test_data_harbour
================================================================================


################################################################################
FILE: .env
################################################################################

DATA_FILE_PATH=/Users/mruthunjai_govindaraju/Downloads/test_data_harbour/test/CRY_Dis.csv
COLLECTION_FILE_PATH=/Users/mruthunjai_govindaraju/Downloads/test_data_harbour/test/CPY_Collection.csv
TARGET_COLUMN=Pancard
DISPLAY_COLUMNS=Name,Credit By,Email,Mobile,Loan Amount,Status
CASE_SENSITIVE=true

# # ============================================================================
# # PAYMENT STATUS TOOL - CONFIGURATION
# # ============================================================================
# # This file contains the fixed configuration for the application.
# # Do not edit unless you know what you're doing.
# # ============================================================================

# # Column Configuration
# TARGET_COLUMN=Pancard
# DISPLAY_COLUMNS=Name,Credit By,Email,Mobile,Loan Amount,Status
# CASE_SENSITIVE=true

# # Database Configuration
# DATABASE_DIR=./data
# MAX_HISTORY_ENTRIES=1000
# AUTO_BACKUP=true

# # UI Configuration
# DEFAULT_WINDOW_WIDTH=1200
# DEFAULT_WINDOW_HEIGHT=800
# SHOW_WELCOME_SCREEN=true

# # Processing Configuration
# GRACE_DAYS=3
# DATE_FORMAT=%Y-%m-%d
# TIME_FORMAT=%H:%M:%S


################################################################################
FILE: app.py
################################################################################

import sys
from pathlib import Path
from PySide6.QtGui import QColor, QIcon
from PySide6.QtWidgets import (
    QApplication, QWidget, QLabel, QPushButton, QFileDialog,
    QVBoxLayout, QHBoxLayout, QLineEdit, QMessageBox, QTableWidget,
    QTableWidgetItem, QHeaderView, QFrame
)
from PySide6.QtCore import Qt

from logic import (
    process_uploaded_files,
    evaluate_payment_across_all_products
)

class PaymentApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Customer 360 Insight")
        logo_path = Path("360logo.png")
        if logo_path.exists():
            self.setWindowIcon(QIcon(str(logo_path)))
        self.setMinimumSize(1100, 650)

        self.disbursed_path = None
        self.collection_path = None

        self.apply_styles()
        self.init_ui()

    # =======================
    # STYLES (UI ONLY)
    # =======================
    def apply_styles(self):
        self.setStyleSheet("""
            QWidget {
                font-family: 'Segoe UI', 'Inter', Arial;
                font-size: 14px;
                background-color: #f6f7fb;
                color: #111827;
            }

            QLabel#TitleLabel {
                font-size: 26px;
                font-weight: 600;
                color: #1f2937;
                padding: 12px 0;
            }

            QLabel.section {
                font-size: 15px;
                font-weight: 600;
                color: #374151;
            }

            QPushButton {
                background-color: #2563eb;
                color: white;
                border-radius: 6px;
                padding: 8px 16px;
                font-weight: 500;
            }

            QPushButton:hover {
                background-color: #1d4ed8;
            }

            QPushButton:disabled {
                background-color: #9ca3af;
            }

            QLineEdit {
                padding: 8px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                background-color: white;
            }

            QLineEdit:focus {
                border: 1px solid #2563eb;
            }

            QTableWidget {
                background-color: white;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
            }

            QHeaderView::section {
                background-color: #f1f5f9;
                padding: 8px;
                border: none;
                font-weight: 600;
                color: #374151;
            }

            QTableWidget::item {
                padding: 6px;
            }
        """)

    # =======================
    # UI LAYOUT
    # =======================
    def init_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setSpacing(14)
        main_layout.setContentsMargins(20, 20, 20, 20)
        upload_label = QLabel("Upload Files")
        upload_label.setProperty("class", "section")
        main_layout.addWidget(upload_label)

        file_layout = QHBoxLayout()
        self.disbursed_btn = QPushButton("Upload Disbursed CSV")
        self.disbursed_btn.clicked.connect(self.load_disbursed)

        self.collection_btn = QPushButton("Upload Collection CSV")
        self.collection_btn.clicked.connect(self.load_collection)

        self.process_btn = QPushButton("Process Files")
        self.process_btn.clicked.connect(self.process_files)

        file_layout.addWidget(self.disbursed_btn)
        file_layout.addWidget(self.collection_btn)
        file_layout.addStretch()
        file_layout.addWidget(self.process_btn)

        main_layout.addLayout(file_layout)
        main_layout.addWidget(self.hline())

        pan_label = QLabel("PAN Search")
        pan_label.setProperty("class", "section")
        main_layout.addWidget(pan_label)

        pan_layout = QHBoxLayout()
        self.pan_input = QLineEdit()
        self.pan_input.setPlaceholderText("Enter PAN (e.g. BBUPM2364P)")

        self.search_btn = QPushButton("Search PAN")
        self.search_btn.clicked.connect(self.search_pan)

        pan_layout.addWidget(self.pan_input)
        pan_layout.addWidget(self.search_btn)

        main_layout.addLayout(pan_layout)
        main_layout.addWidget(self.hline())

        results_label = QLabel("Results")
        results_label.setProperty("class", "section")
        main_layout.addWidget(results_label)

        self.table = QTableWidget()
        self.table.setAlternatingRowColors(True)
        self.table.verticalHeader().setVisible(False)
        self.table.setShowGrid(False)

        self.table.setHorizontalScrollMode(QTableWidget.ScrollPerPixel)
        self.table.setVerticalScrollMode(QTableWidget.ScrollPerPixel)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.table.horizontalScrollBar().setVisible(True)

        main_layout.addWidget(self.table)
        self.setLayout(main_layout)

    def hline(self):
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        line.setStyleSheet("color: #e5e7eb;")
        return line

    # =======================
    # ACTIONS
    # =======================
    def load_disbursed(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Disbursed CSV", "", "CSV Files (*.csv)")
        if path:
            self.disbursed_path = Path(path)
            self.disbursed_btn.setText(f"Disbursed: {Path(path).name}")

    def load_collection(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Collection CSV", "", "CSV Files (*.csv)")
        if path:
            self.collection_path = Path(path)
            self.collection_btn.setText(f"Collection: {Path(path).name}")

    def process_files(self):
        if not self.disbursed_path or not self.collection_path:
            QMessageBox.warning(self, "Missing Files", "Please upload both CSV files.")
            return
        try:
            product, conn = process_uploaded_files(self.disbursed_path, self.collection_path)
            conn.close()
            QMessageBox.information(self, "Success", f"Product DB ready: {product}.db")
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))

    def search_pan(self):
        pan = self.pan_input.text().strip()
        if not pan:
            QMessageBox.warning(self, "Invalid PAN", "PAN cannot be empty.")
            return
        try:
            result = evaluate_payment_across_all_products(pan)
            df = result["table"]
            if df.empty:
                QMessageBox.information(self, "No Results", "No records found.")
                self.table.clear()
                return
            self.populate_table(df)
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))

    # =======================
    # TABLE POPULATION (WITH INDEX)
    # =======================
    def populate_table(self, df):
        self.table.clear()

        total_rows = len(df)
        total_cols = len(df.columns) + 1  # +1 for index

        self.table.setRowCount(total_rows)
        self.table.setColumnCount(total_cols)

        headers = ["S. No."] + df.columns.tolist()
        self.table.setHorizontalHeaderLabels(headers)

        PRODUCT_COLORS = {
            "ELI": QColor("#fde2e2"),
            "NBL": QColor("#e0f2fe"),
            "CPY": QColor("#ecfdf5"),
            "LDR": QColor("#f3e8ff"),
        }

        product_col_index = (
            df.columns.get_loc("Product") if "Product" in df.columns else None
        )

        for row in range(total_rows):
            # Index column
            index_item = QTableWidgetItem(str(row + 1))
            index_item.setTextAlignment(Qt.AlignCenter)

            product_value = (
                str(df.iat[row, product_col_index]).upper()
                if product_col_index is not None
                else None
            )
            row_color = PRODUCT_COLORS.get(product_value)

            if row_color:
                index_item.setBackground(row_color)

            self.table.setItem(row, 0, index_item)

            for col in range(len(df.columns)):
                value = str(df.iat[row, col])
                item = QTableWidgetItem(value)
                item.setToolTip(value)

                if row_color:
                    item.setBackground(row_color)

                self.table.setItem(row, col + 1, item)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PaymentApp()
    window.show()
    sys.exit(app.exec())



################################################################################
FILE: logic.py
################################################################################

import os
from pathlib import Path
from dotenv import load_dotenv
import pandas as pd
import sqlite3
import glob


# =======================
# CONFIGxoll
# =======================

load_dotenv()

TARGET_COLUMN = os.getenv("TARGET_COLUMN")  # Pancard
CASE_SENSITIVE = os.getenv("CASE_SENSITIVE", "true").lower() == "true"

# Normalize DISPLAY_COLUMNS too (spaces → "")
DISPLAY_COLUMNS = [
    c.strip().replace(" ", "")
    for c in os.getenv("DISPLAY_COLUMNS", "").split(",")
    if c.strip()
]

# Updated constants to match normalized headers (spaces → "")
LEAD_ID_COL = "LeadID"
REPAYMENT_DATE_COL = "RepayDate"
COLLECTION_DATE_COL = "CollectedDate"
LOAN_NO_COL = "LoanNo"

REQUIRED_DISBURSED_COLS = {
    TARGET_COLUMN,
    LOAN_NO_COL,
    LEAD_ID_COL,
    REPAYMENT_DATE_COL,
    *DISPLAY_COLUMNS,
}

REQUIRED_COLLECTION_COLS = {
    LOAN_NO_COL,
    LEAD_ID_COL,
    COLLECTION_DATE_COL,
}

INT_LEAD_ID = "__lead_id"
INT_REPAY_DATE = "__repay_date"
INT_COLLECTION_DATE = "__collection_date"

GRACE_DAYS = 3


def normalize_headers(df: pd.DataFrame) -> pd.DataFrame:
    """Normalize column names: strip whitespace, remove spaces."""
    df.columns = df.columns.str.strip().str.replace(" ", "")
    return df


def read_csv_flexible(path: Path) -> pd.DataFrame:
    """
    Read CSV that may have metadata rows before actual headers.
    Automatically skips rows until valid headers are found.
    Uses only first 20 rows for validation.
    """
    # Try different approaches to find headers
    for skiprows in [0, 1, 2, 3, 5, 10]:
        try:
            df = pd.read_csv(
                path,
                dtype=str,
                low_memory=False,
                skiprows=skiprows,
                nrows=20,  # Just for validation
            )
            df = normalize_headers(df)
            # Check if we have required identifier columns
            if all(col in df.columns for col in [LEAD_ID_COL, LOAN_NO_COL]):
                print(f"✅ Found valid headers after skipping {skiprows} rows")
                return df
        except Exception:
            continue

    # Fallback: search for header row
    all_rows = pd.read_csv(path, header=None, dtype=str).fillna("")
    for i, row in all_rows.iterrows():
        if LEAD_ID_COL.replace(" ", "") in row.values or "Lead ID" in row.values:
            df = pd.read_csv(path, skiprows=i, dtype=str, low_memory=False, nrows=20)
            df = normalize_headers(df)
            if all(col in df.columns for col in [LEAD_ID_COL, LOAN_NO_COL]):
                print(f"✅ Found valid headers at row {i}")
                return df

    raise ValueError(f"Could not find valid headers in {path.name}")


def validate_columns(df: pd.DataFrame, required: set, name: str):
    """Validate required columns exist after normalization."""
    missing = required - set(df.columns)
    if missing:
        print(f"Available columns: {list(df.columns)}")
        print(f"Required columns: {list(required)}")
        raise KeyError(f"{name} missing columns: {sorted(missing)}")


def read_full_csv_flexible(path: Path) -> pd.DataFrame:
    """Read complete CSV with flexible header detection."""
    for skiprows in [0, 1, 2, 3, 5, 10]:
        try:
            df = pd.read_csv(path, dtype=str, low_memory=False, skiprows=skiprows)
            df = normalize_headers(df)
            if LEAD_ID_COL in df.columns and LOAN_NO_COL in df.columns:
                print(f"✅ Reading full CSV with headers at row {skiprows}")
                return df
        except Exception:
            continue

    # Fallback: search for header row
    all_rows = pd.read_csv(path, header=None, dtype=str).fillna("")
    for i, row in all_rows.iterrows():
        if LEAD_ID_COL.replace(" ", "") in row.values or "Lead ID" in row.values:
            df = pd.read_csv(path, skiprows=i, dtype=str, low_memory=False)
            df = normalize_headers(df)
            if LEAD_ID_COL in df.columns and LOAN_NO_COL in df.columns:
                print(f"✅ Full CSV parsed from row {i}")
                return df

    raise ValueError(f"Could not parse full CSV: {path.name}")


def list_product_dbs(base_dir: Path | None = None) -> list[Path]:
    """
    Return all .db files in the given dir (default: CWD).
    """
    if base_dir is None:
        base_dir = Path.cwd()

    return [Path(p) for p in glob.glob(str(base_dir / "*.db"))]


def process_uploaded_files(disbursed_path: Path, collection_path: Path) -> tuple[str, sqlite3.Connection]:
    """
    1. Validate columns exist using flexible CSV reader (sample only).
    2. Extract product from FIRST VALID Loan No cell.
    3. Check both files have SAME product name.
    4. Create/overwrite {PRODUCT}.db in CWD.
    5. Load FULL CSVs into 'disbursed' and 'collection' tables.
    6. Return (product_name, connection).
    """
    # Quick validation - don't load full data yet
    disbursed_df = read_csv_flexible(disbursed_path)
    collection_df = read_csv_flexible(collection_path)

    validate_columns(disbursed_df, REQUIRED_DISBURSED_COLS, "Disbursed")
    validate_columns(collection_df, REQUIRED_COLLECTION_COLS, "Collection")

    def get_first_product(df: pd.DataFrame, col: str) -> str:
        for val in df[col].dropna():
            clean_val = str(val).strip()
            if clean_val and len(clean_val) >= 3:
                return clean_val[:3].upper()
        raise ValueError("No valid Loan No found")

    disbursed_product = get_first_product(disbursed_df, LOAN_NO_COL)
    collection_product = get_first_product(collection_df, LOAN_NO_COL)

    if disbursed_product != collection_product:
        raise ValueError(f"Product mismatch - Disbursed: {disbursed_product}, Collection: {collection_product}")

    product_name = disbursed_product
    db_path = Path.cwd() / f"{product_name}.db"

    if db_path.exists():
        print(f"⚠️  Using existing DB: {db_path}")
    else:
        print(f"✅ Creating DB: {db_path}")

    conn = sqlite3.connect(db_path)

    # Load full CSVs into DB tables (dump everything)
    full_disbursed = read_full_csv_flexible(disbursed_path)
    full_collection = read_full_csv_flexible(collection_path)

    # Persist complete data for this product
    full_disbursed.to_sql("disbursed", conn, if_exists="replace", index=False)
    full_collection.to_sql("collection", conn, if_exists="replace", index=False)
    print(
        f"✅ Loaded disbursed ({len(full_disbursed)}) "
        f"and collection ({len(full_collection)}) into DB for product {product_name}"
    )

    return product_name, conn


def evaluate_payment_status_for_conn(pan_value: str, conn: sqlite3.Connection) -> dict:
    """
    Core evaluator for a single product DB connection.
    """
    if not pan_value.strip():
        raise ValueError("PAN cannot be empty")

    value = pan_value.strip()
    pan_col = TARGET_COLUMN.replace(" ", "")

    # Filter disbursed records by PAN in SQL
    if CASE_SENSITIVE:
        disbursed_pan_df = pd.read_sql_query(
            f"SELECT * FROM disbursed WHERE {pan_col} = ?",
            conn,
            params=[value],
        )
    else:
        disbursed_pan_df = pd.read_sql_query(
            f"SELECT * FROM disbursed WHERE LOWER({pan_col}) = LOWER(?)",
            conn,
            params=[value],
        )

    if disbursed_pan_df.empty:
        result_df = pd.DataFrame()
    else:
        # Read all collection data for this product
        collection_df = pd.read_sql_query("SELECT * FROM collection", conn)

        disbursed_pan_df = normalize_headers(disbursed_pan_df)
        collection_df = normalize_headers(collection_df)

        disbursed_pan_df = disbursed_pan_df.rename(
            columns={LEAD_ID_COL: INT_LEAD_ID, REPAYMENT_DATE_COL: INT_REPAY_DATE}
        )
        collection_df = collection_df.rename(
            columns={LEAD_ID_COL: INT_LEAD_ID, COLLECTION_DATE_COL: INT_COLLECTION_DATE}
        )

        disbursed_pan_df[INT_REPAY_DATE] = pd.to_datetime(
            disbursed_pan_df[INT_REPAY_DATE], errors="coerce"
        )
        collection_df[INT_COLLECTION_DATE] = pd.to_datetime(
            collection_df[INT_COLLECTION_DATE], errors="coerce"
        )

        collection_agg = collection_df.groupby(INT_LEAD_ID, as_index=False)[
            INT_COLLECTION_DATE
        ].max()
        merged = pd.merge(disbursed_pan_df, collection_agg, on=INT_LEAD_ID, how="left")

        rows = []
        for _, row in merged.iterrows():
            repay_date = row[INT_REPAY_DATE]
            collect_date = row[INT_COLLECTION_DATE]

            if pd.isna(collect_date):
                status = "NOT_COLLECTED"
            elif collect_date < repay_date:
                status = "EARLY"
            elif collect_date == repay_date:
                status = "ON_TIME"
            else:
                delay_days = (collect_date - repay_date).days
                status = "COOLING_PERIOD" if delay_days <= GRACE_DAYS else "LATE"

            record = {
                "pan": pan_value,
                # "query_timestamp": pd.Timestamp.now().isoformat(),
                "LeadID": row[INT_LEAD_ID],
                "RepayDate": repay_date.date() if pd.notna(repay_date) else None,
                "CollectionDate": collect_date.date() if pd.notna(collect_date) else None,
                "PaymentStatus": status,
                **{col: row.get(col) for col in DISPLAY_COLUMNS},
            }
            rows.append(record)

        result_df = pd.DataFrame(rows)

    # Save ONLY query results to DB 'queries' table
    if not result_df.empty:
        result_df.to_sql("queries", conn, if_exists="append", index=False)
        print(f"✅ Saved {len(result_df)} query results to DB")
    else:
        print("ℹ️  No results to save")

    return {"pan": pan_value, "total_records": len(result_df), "table": result_df}


def evaluate_payment_status(pan_value: str, conn: sqlite3.Connection) -> dict:
    """
    Backwards-compatible wrapper for single-DB evaluation.
    """
    return evaluate_payment_status_for_conn(pan_value, conn)


def evaluate_payment_across_all_products(pan_value: str) -> dict:
    """
    Check the given PAN in every product DB (*.db) in the current directory.
    Returns:
      {
        "pan": <PAN>,
        "total_records": <int>,
        "table": <DataFrame with Product column>
      }
    """
    if not pan_value.strip():
        raise ValueError("PAN cannot be empty")

    db_paths = list_product_dbs()
    all_rows = []

    for db_path in db_paths:
        product_name = db_path.stem  # "NBL" from "NBL.db"
        conn = None
        try:
            conn = sqlite3.connect(db_path)
            result = evaluate_payment_status_for_conn(pan_value, conn)
            df = result["table"]
            if not df.empty:
                df = df.copy()
                df["Product"] = product_name
                all_rows.append(df)
        except Exception as e:
            print(f"⚠️  Skipping DB {db_path} due to error: {e}")
        finally:
            if conn is not None:
                try:
                    conn.close()
                except Exception:
                    pass

    if all_rows:
        combined = pd.concat(all_rows, ignore_index=True)
    else:
        combined = pd.DataFrame()

    return {
        "pan": pan_value,
        "total_records": len(combined),
        "table": combined,
    }




################################################################################
FILE: test.py
################################################################################

import os

# ==== CONFIG ====
OUTPUT_FILE = "FULL_PROJECT_CODE_DUMP.txt"

INCLUDE_EXTENSIONS = {
    ".py", ".html", ".css", ".js", ".env"
}

EXCLUDE_DIRS = {
    "venv",
    "__pycache__",
    ".git",
    "node_modules",
    "staticfiles",
    ".idea",
    ".vscode"
}

# =================

def should_include_file(filename):
    if filename == ".env":
        return True
    return os.path.splitext(filename)[1] in INCLUDE_EXTENSIONS


def dump_code(root_dir):
    with open(OUTPUT_FILE, "w", encoding="utf-8", errors="ignore") as out:
        out.write("=" * 80 + "\n")
        out.write("FULL PROJECT CODE DUMP\n")
        out.write(f"Root Directory: {root_dir}\n")
        out.write("=" * 80 + "\n\n")

        for root, dirs, files in os.walk(root_dir):
            # Remove excluded directories in-place
            dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]

            for file in sorted(files):
                if should_include_file(file):
                    file_path = os.path.join(root, file)
                    rel_path = os.path.relpath(file_path, root_dir)

                    out.write("\n" + "#" * 80 + "\n")
                    out.write(f"FILE: {rel_path}\n")
                    out.write("#" * 80 + "\n\n")

                    try:
                        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                            out.write(f.read())
                    except Exception as e:
                        out.write(f"<< ERROR READING FILE: {e} >>")

                    out.write("\n\n")

    print(f"\n✅ Code dump created: {OUTPUT_FILE}")


if __name__ == "__main__":
    dump_code(os.getcwd())


