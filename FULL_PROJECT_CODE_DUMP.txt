================================================================================
FULL PROJECT CODE DUMP
Root Directory: /Users/mruthunjai_govindaraju/Downloads/test_data_harbour
================================================================================


################################################################################
FILE: .env
################################################################################

DATA_FILE_PATH=/Users/mruthunjai_govindaraju/Downloads/test_data_harbour/test/CRY_Dis.csv
COLLECTION_FILE_PATH=/Users/mruthunjai_govindaraju/Downloads/test_data_harbour/test/CPY_Collection.csv
TARGET_COLUMN=Pancard
DISPLAY_COLUMNS=Name,Credit By,Email,Mobile,Loan Amount,Status
CASE_SENSITIVE=true

# # ============================================================================
# # PAYMENT STATUS TOOL - CONFIGURATION
# # ============================================================================
# # This file contains the fixed configuration for the application.
# # Do not edit unless you know what you're doing.
# # ============================================================================

# # Column Configuration
# TARGET_COLUMN=Pancard
# DISPLAY_COLUMNS=Name,Credit By,Email,Mobile,Loan Amount,Status
# CASE_SENSITIVE=true

# # Database Configuration
# DATABASE_DIR=./data
# MAX_HISTORY_ENTRIES=1000
# AUTO_BACKUP=true

# # UI Configuration
# DEFAULT_WINDOW_WIDTH=1200
# DEFAULT_WINDOW_HEIGHT=800
# SHOW_WELCOME_SCREEN=true

# # Processing Configuration
# GRACE_DAYS=3
# DATE_FORMAT=%Y-%m-%d
# TIME_FORMAT=%H:%M:%S


################################################################################
FILE: app.py
################################################################################

import sys
from pathlib import Path
import sqlite3
import pandas as pd

from PySide6.QtGui import QColor, QIcon
from PySide6.QtWidgets import (
    QApplication, QWidget, QLabel, QPushButton, QFileDialog,
    QVBoxLayout, QHBoxLayout, QLineEdit, QMessageBox, QTableWidget,
    QTableWidgetItem, QHeaderView, QFrame
)
from PySide6.QtCore import Qt

from logic import (
    process_uploaded_files,
    evaluate_payment_across_all_products,
    list_product_dbs
)


class PaymentApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Customer 360 Insight")
        logo_path = Path("360logo.png")
        if logo_path.exists():
            self.setWindowIcon(QIcon(str(logo_path)))
        self.setMinimumSize(1100, 650)

        self.disbursed_path = None
        self.collection_path = None
        self.last_sql_df = None  # <-- SQL result cache

        self.apply_styles()
        self.init_ui()

    # =======================
    # STYLES (UI ONLY)
    # =======================
    def apply_styles(self):
        self.setStyleSheet("""
            QWidget {
                font-family: 'Segoe UI', 'Inter', Arial;
                font-size: 14px;
                background-color: #f6f7fb;
                color: #111827;
            }

            QLabel.section {
                font-size: 15px;
                font-weight: 600;
                color: #374151;
            }

            QPushButton {
                background-color: #2563eb;
                color: white;
                border-radius: 6px;
                padding: 8px 16px;
                font-weight: 500;
            }

            QPushButton:hover {
                background-color: #1d4ed8;
            }

            QPushButton:disabled {
                background-color: #9ca3af;
            }

            QLineEdit {
                padding: 8px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                background-color: white;
            }

            QLineEdit:focus {
                border: 1px solid #2563eb;
            }

            QTableWidget {
                background-color: white;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
            }

            QHeaderView::section {
                background-color: #f1f5f9;
                padding: 8px;
                border: none;
                font-weight: 600;
                color: #374151;
            }

            QTableWidget::item {
                padding: 6px;
            }
        """)

    # =======================
    # UI LAYOUT
    # =======================
    def init_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setSpacing(14)
        main_layout.setContentsMargins(20, 20, 20, 20)

        # ---- Upload section ----
        upload_label = QLabel("Upload Files")
        upload_label.setProperty("class", "section")
        main_layout.addWidget(upload_label)

        file_layout = QHBoxLayout()
        self.disbursed_btn = QPushButton("Upload Disbursed CSV")
        self.disbursed_btn.clicked.connect(self.load_disbursed)

        self.collection_btn = QPushButton("Upload Collection CSV")
        self.collection_btn.clicked.connect(self.load_collection)

        self.process_btn = QPushButton("Process Files")
        self.process_btn.clicked.connect(self.process_files)

        file_layout.addWidget(self.disbursed_btn)
        file_layout.addWidget(self.collection_btn)
        file_layout.addStretch()
        file_layout.addWidget(self.process_btn)

        main_layout.addLayout(file_layout)
        main_layout.addWidget(self.hline())

        # ---- PAN Search ----
        pan_label = QLabel("PAN Search")
        pan_label.setProperty("class", "section")
        main_layout.addWidget(pan_label)

        pan_layout = QHBoxLayout()
        self.pan_input = QLineEdit()
        self.pan_input.setPlaceholderText("Enter PAN (e.g. BBUPM2364P)")

        self.search_btn = QPushButton("Search PAN")
        self.search_btn.clicked.connect(self.search_pan)

        pan_layout.addWidget(self.pan_input)
        pan_layout.addWidget(self.search_btn)
        main_layout.addLayout(pan_layout)
        main_layout.addWidget(self.hline())

        # ---- SQL Query Section (NEW) ----
        sql_label = QLabel("SQL Query")
        sql_label.setProperty("class", "section")
        main_layout.addWidget(sql_label)

        sql_layout = QHBoxLayout()
        self.sql_input = QLineEdit()
        self.sql_input.setPlaceholderText(
            "Enter SQL query (e.g. SELECT * FROM disbursed LIMIT 50)"
        )

        self.run_sql_btn = QPushButton("Run Query")
        self.run_sql_btn.clicked.connect(self.run_sql_query)

        self.export_sql_btn = QPushButton("Export Result")
        self.export_sql_btn.setEnabled(False)
        self.export_sql_btn.clicked.connect(self.export_sql_result)

        sql_layout.addWidget(self.sql_input)
        sql_layout.addWidget(self.run_sql_btn)
        sql_layout.addWidget(self.export_sql_btn)

        main_layout.addLayout(sql_layout)
        main_layout.addWidget(self.hline())

        # ---- Results ----
        results_label = QLabel("Results")
        results_label.setProperty("class", "section")
        main_layout.addWidget(results_label)

        self.table = QTableWidget()
        self.table.setAlternatingRowColors(True)
        self.table.verticalHeader().setVisible(False)
        self.table.setShowGrid(False)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)

        main_layout.addWidget(self.table)
        self.setLayout(main_layout)

    def hline(self):
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        line.setStyleSheet("color: #e5e7eb;")
        return line

    # =======================
    # ACTIONS
    # =======================
    def load_disbursed(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Disbursed CSV", "", "CSV Files (*.csv)")
        if path:
            self.disbursed_path = Path(path)
            self.disbursed_btn.setText(f"Disbursed: {Path(path).name}")

    def load_collection(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Collection CSV", "", "CSV Files (*.csv)")
        if path:
            self.collection_path = Path(path)
            self.collection_btn.setText(f"Collection: {Path(path).name}")

    def process_files(self):
        if not self.disbursed_path or not self.collection_path:
            QMessageBox.warning(self, "Missing Files", "Please upload both CSV files.")
            return
        try:
            product, conn = process_uploaded_files(self.disbursed_path, self.collection_path)
            conn.close()
            QMessageBox.information(self, "Success", f"Product DB ready: {product}.db")
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))

    def search_pan(self):
        pan = self.pan_input.text().strip()
        if not pan:
            QMessageBox.warning(self, "Invalid PAN", "PAN cannot be empty.")
            return
        try:
            result = evaluate_payment_across_all_products(pan)
            df = result["table"]
            if df.empty:
                QMessageBox.information(self, "No Results", "No records found.")
                self.table.clear()
                return
            self.populate_table(df)
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))

    # =======================
    # SQL QUERY (NEW)
    # =======================
    def run_sql_query(self):
        query = self.sql_input.text().strip()
        if not query:
            QMessageBox.warning(self, "Invalid Query", "SQL query cannot be empty.")
            return

        all_results = []

        try:
            for db in list_product_dbs():
                conn = sqlite3.connect(db)
                try:
                    df = pd.read_sql_query(query, conn)
                    if not df.empty:
                        df["Product"] = db.stem
                        all_results.append(df)
                finally:
                    conn.close()

            if not all_results:
                QMessageBox.information(self, "No Results", "Query returned no rows.")
                self.table.clear()
                self.export_sql_btn.setEnabled(False)
                return

            combined = pd.concat(all_results, ignore_index=True)
            self.last_sql_df = combined
            self.populate_table(combined)
            self.export_sql_btn.setEnabled(True)

        except Exception as e:
            QMessageBox.critical(self, "SQL Error", str(e))

    def export_sql_result(self):
        if self.last_sql_df is None or self.last_sql_df.empty:
            QMessageBox.warning(self, "Nothing to Export", "No query result available.")
            return

        path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Query Result",
            "sql_query_result.csv",
            "CSV Files (*.csv)"
        )

        if path:
            try:
                self.last_sql_df.to_csv(path, index=False)
                QMessageBox.information(self, "Exported", f"Saved to {path}")
            except Exception as e:
                QMessageBox.critical(self, "Export Failed", str(e))

    # =======================
    # TABLE POPULATION
    # =======================
    def populate_table(self, df):
        self.table.clear()

        rows = len(df)
        cols = len(df.columns) + 1
        self.table.setRowCount(rows)
        self.table.setColumnCount(cols)

        self.table.setHorizontalHeaderLabels(["S. No."] + df.columns.tolist())

        PRODUCT_COLORS = {
            "ELI": QColor("#fde2e2"),
            "NBL": QColor("#e0f2fe"),
            "CPY": QColor("#ecfdf5"),
            "LDR": QColor("#f3e8ff"),
        }

        product_col_index = df.columns.get_loc("Product") if "Product" in df.columns else None

        for r in range(rows):
            index_item = QTableWidgetItem(str(r + 1))
            index_item.setTextAlignment(Qt.AlignCenter)

            row_color = None
            if product_col_index is not None:
                product = str(df.iat[r, product_col_index]).upper()
                row_color = PRODUCT_COLORS.get(product)

            if row_color:
                index_item.setBackground(row_color)

            self.table.setItem(r, 0, index_item)

            for c, col in enumerate(df.columns):
                val = str(df.iat[r, c])
                item = QTableWidgetItem(val)
                item.setToolTip(val)
                if row_color:
                    item.setBackground(row_color)
                self.table.setItem(r, c + 1, item)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PaymentApp()
    window.show()
    sys.exit(app.exec())



################################################################################
FILE: logic.py
################################################################################

import os
from pathlib import Path
from dotenv import load_dotenv
import pandas as pd
import sqlite3
import glob

# =======================
# CONFIG
# =======================

load_dotenv()

TARGET_COLUMN = os.getenv("TARGET_COLUMN")  # Pancard
CASE_SENSITIVE = os.getenv("CASE_SENSITIVE", "true").lower() == "true"

DISPLAY_COLUMNS = [
    c.strip().replace(" ", "")
    for c in os.getenv("DISPLAY_COLUMNS", "").split(",")
    if c.strip()
]

LEAD_ID_COL = "LeadID"
REPAYMENT_DATE_COL = "RepayDate"
COLLECTION_DATE_COL = "CollectedDate"
LOAN_NO_COL = "LoanNo"

REQUIRED_DISBURSED_COLS = {
    TARGET_COLUMN,
    LOAN_NO_COL,
    LEAD_ID_COL,
    REPAYMENT_DATE_COL,
    *DISPLAY_COLUMNS,
}

REQUIRED_COLLECTION_COLS = {
    LOAN_NO_COL,
    LEAD_ID_COL,
    COLLECTION_DATE_COL,
}

INT_LEAD_ID = "__lead_id"
INT_REPAY_DATE = "__repay_date"
INT_COLLECTION_DATE = "__collection_date"

GRACE_DAYS = 3


# =======================
# HELPERS
# =======================

def normalize_headers(df: pd.DataFrame) -> pd.DataFrame:
    df.columns = df.columns.str.strip().str.replace(" ", "")
    return df


def validate_columns(df: pd.DataFrame, required: set, name: str):
    missing = required - set(df.columns)
    if missing:
        raise KeyError(f"{name} missing columns: {sorted(missing)}")
def read_csv_flexible(path: Path, sample_only=False) -> pd.DataFrame:
    encodings_to_try = ["utf-8", "utf-8-sig", "latin1", "cp1252"]

    for encoding in encodings_to_try:
        for skiprows in [0, 1, 2, 3, 5, 10]:
            try:
                df = pd.read_csv(
                    path,
                    dtype=str,
                    low_memory=False,
                    skiprows=skiprows,
                    encoding=encoding,
                    nrows=20 if sample_only else None,
                )
                df = normalize_headers(df)

                if LEAD_ID_COL in df.columns and LOAN_NO_COL in df.columns:
                    print(f"✅ Parsed {path.name} using encoding={encoding}, skiprows={skiprows}")
                    return df

            except UnicodeDecodeError:
                continue
            except Exception:
                continue

    raise ValueError(
        f"Could not parse CSV {path.name} — unsupported encoding or corrupt file"
    )



def table_exists(conn: sqlite3.Connection, table_name: str) -> bool:
    cur = conn.cursor()
    cur.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name=?;",
        (table_name,),
    )
    return cur.fetchone() is not None


def upsert_dataframe(
    conn: sqlite3.Connection,
    table_name: str,
    new_df: pd.DataFrame,
):
    """
    Insert only NEW rows (exact full-row match) into table.
    """
    new_df = normalize_headers(new_df)

    if table_exists(conn, table_name):
        existing_df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
        existing_df = normalize_headers(existing_df)

        combined = pd.concat([existing_df, new_df], ignore_index=True)
        combined = combined.drop_duplicates()

        combined.to_sql(table_name, conn, if_exists="replace", index=False)
        inserted = len(combined) - len(existing_df)
    else:
        new_df = new_df.drop_duplicates()
        new_df.to_sql(table_name, conn, if_exists="replace", index=False)
        inserted = len(new_df)

    print(f"✅ {table_name}: inserted {inserted} new rows")


# =======================
# MAIN INGESTION
# =======================

def process_uploaded_files(
    disbursed_path: Path,
    collection_path: Path,
) -> tuple[str, sqlite3.Connection]:

    disbursed_sample = read_csv_flexible(disbursed_path, sample_only=True)
    collection_sample = read_csv_flexible(collection_path, sample_only=True)

    validate_columns(disbursed_sample, REQUIRED_DISBURSED_COLS, "Disbursed")
    validate_columns(collection_sample, REQUIRED_COLLECTION_COLS, "Collection")

    def get_product(df: pd.DataFrame) -> str:
        for val in df[LOAN_NO_COL].dropna():
            val = str(val).strip()
            if len(val) >= 3:
                return val[:3].upper()
        raise ValueError("Could not infer product")

    product_name = get_product(disbursed_sample)
    if get_product(collection_sample) != product_name:
        raise ValueError("Product mismatch between files")

    db_path = Path.cwd() / f"{product_name}.db"
    conn = sqlite3.connect(db_path)

    # Read FULL CSVs
    full_disbursed = read_csv_flexible(disbursed_path)
    full_collection = read_csv_flexible(collection_path)

    # UPSERT behavior
    upsert_dataframe(conn, "disbursed", full_disbursed)
    upsert_dataframe(conn, "collection", full_collection)

    return product_name, conn


# =======================
# EVALUATION (UNCHANGED)
# =======================

def list_product_dbs(base_dir: Path | None = None) -> list[Path]:
    if base_dir is None:
        base_dir = Path.cwd()
    return [Path(p) for p in glob.glob(str(base_dir / "*.db"))]


def evaluate_payment_status_for_conn(pan_value: str, conn: sqlite3.Connection) -> dict:
    if not pan_value.strip():
        raise ValueError("PAN cannot be empty")

    pan_col = TARGET_COLUMN.replace(" ", "")
    value = pan_value.strip()

    if CASE_SENSITIVE:
        disbursed_df = pd.read_sql_query(
            f"SELECT * FROM disbursed WHERE {pan_col} = ?",
            conn,
            params=[value],
        )
    else:
        disbursed_df = pd.read_sql_query(
            f"SELECT * FROM disbursed WHERE LOWER({pan_col}) = LOWER(?)",
            conn,
            params=[value],
        )

    if disbursed_df.empty:
        return {"pan": pan_value, "total_records": 0, "table": pd.DataFrame()}

    collection_df = pd.read_sql_query("SELECT * FROM collection", conn)

    disbursed_df = normalize_headers(disbursed_df)
    collection_df = normalize_headers(collection_df)

    disbursed_df = disbursed_df.rename(
        columns={LEAD_ID_COL: INT_LEAD_ID, REPAYMENT_DATE_COL: INT_REPAY_DATE}
    )
    collection_df = collection_df.rename(
        columns={LEAD_ID_COL: INT_LEAD_ID, COLLECTION_DATE_COL: INT_COLLECTION_DATE}
    )

    disbursed_df[INT_REPAY_DATE] = pd.to_datetime(disbursed_df[INT_REPAY_DATE], errors="coerce")
    collection_df[INT_COLLECTION_DATE] = pd.to_datetime(collection_df[INT_COLLECTION_DATE], errors="coerce")

    collection_agg = collection_df.groupby(INT_LEAD_ID, as_index=False)[INT_COLLECTION_DATE].max()
    merged = pd.merge(disbursed_df, collection_agg, on=INT_LEAD_ID, how="left")

    rows = []
    for _, row in merged.iterrows():
        repay = row[INT_REPAY_DATE]
        collect = row[INT_COLLECTION_DATE]

        if pd.isna(collect):
            status = "NOT_COLLECTED"
        elif collect < repay:
            status = "EARLY"
        elif collect == repay:
            status = "ON_TIME"
        else:
            status = "COOLING_PERIOD" if (collect - repay).days <= GRACE_DAYS else "LATE"

        rows.append({
            "pan": pan_value,
            "LeadID": row[INT_LEAD_ID],
            "RepayDate": repay.date() if pd.notna(repay) else None,
            "CollectionDate": collect.date() if pd.notna(collect) else None,
            "PaymentStatus": status,
            **{col: row.get(col) for col in DISPLAY_COLUMNS},
        })

    result_df = pd.DataFrame(rows)
    result_df.to_sql("queries", conn, if_exists="append", index=False)

    return {
        "pan": pan_value,
        "total_records": len(result_df),
        "table": result_df,
    }


def evaluate_payment_across_all_products(pan_value: str) -> dict:
    all_rows = []

    for db in list_product_dbs():
        conn = sqlite3.connect(db)
        try:
            result = evaluate_payment_status_for_conn(pan_value, conn)
            df = result["table"]
            if not df.empty:
                df["Product"] = db.stem
                all_rows.append(df)
        finally:
            conn.close()

    combined = pd.concat(all_rows, ignore_index=True) if all_rows else pd.DataFrame()
    return {"pan": pan_value, "total_records": len(combined), "table": combined}



################################################################################
FILE: test.py
################################################################################

import os

# ==== CONFIG ====
OUTPUT_FILE = "FULL_PROJECT_CODE_DUMP.txt"

INCLUDE_EXTENSIONS = {
    ".py", ".html", ".css", ".js", ".env"
}

EXCLUDE_DIRS = {
    "venv",
    "__pycache__",
    ".git",
    "node_modules",
    "staticfiles",
    ".idea",
    ".vscode"
}

# =================

def should_include_file(filename):
    if filename == ".env":
        return True
    return os.path.splitext(filename)[1] in INCLUDE_EXTENSIONS


def dump_code(root_dir):
    with open(OUTPUT_FILE, "w", encoding="utf-8", errors="ignore") as out:
        out.write("=" * 80 + "\n")
        out.write("FULL PROJECT CODE DUMP\n")
        out.write(f"Root Directory: {root_dir}\n")
        out.write("=" * 80 + "\n\n")

        for root, dirs, files in os.walk(root_dir):
            # Remove excluded directories in-place
            dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]

            for file in sorted(files):
                if should_include_file(file):
                    file_path = os.path.join(root, file)
                    rel_path = os.path.relpath(file_path, root_dir)

                    out.write("\n" + "#" * 80 + "\n")
                    out.write(f"FILE: {rel_path}\n")
                    out.write("#" * 80 + "\n\n")

                    try:
                        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                            out.write(f.read())
                    except Exception as e:
                        out.write(f"<< ERROR READING FILE: {e} >>")

                    out.write("\n\n")

    print(f"\n✅ Code dump created: {OUTPUT_FILE}")


if __name__ == "__main__":
    dump_code(os.getcwd())


